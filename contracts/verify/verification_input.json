{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\nabstract contract Pausable is Context {\n    event Paused(address account);\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    constructor() {\n        _paused = false;\n    }\n\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"
    },
    "contracts/BettingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\ncontract BettingPool is Ownable, ReentrancyGuard, Pausable {\n    // Oracle Management\n    struct Oracle {\n        bool isActive;\n        string dataSource;    // e.g., \"API-Football\", \"SportsData.io\"\n        uint256 stake;       // Amount staked by the oracle\n        uint256 reputation;  // Reputation score\n    }\n\n    // Game Management\n    enum GameStatus { PENDING, IN_PROGRESS, FINISHED, DISPUTED }\n    \n    struct Game {\n        uint256 id;\n        string homeTeam;\n        string awayTeam;\n        uint256 startTime;\n        GameStatus status;\n        uint8 result;        // 0 = Not Set, 1 = Home Win, 2 = Away Win, 3 = Draw\n        uint256 totalBets;\n        uint256 totalAmount;\n        mapping(address => uint256) bets;\n        mapping(address => uint8) predictions;\n    }\n\n    // Result Proposal Management\n    struct ResultProposal {\n        uint8 result;\n        uint256 timestamp;\n        uint256 confirmations;\n        mapping(address => bool) hasConfirmed;\n        bool isDisputed;\n        uint256 disputeStake;\n        address disputer;\n    }\n\n    // Constants\n    uint256 public constant MIN_ORACLE_STAKE = 1000 ether;  // Min stake required to become an oracle\n    uint256 public constant MIN_BET_AMOUNT = 0.01 ether;    // Minimum bet amount\n    uint256 public constant RESULT_CONFIRMATION_THRESHOLD = 2; // Number of confirmations needed\n    uint256 public constant DISPUTE_STAKE = 500 ether;      // Stake required to dispute a result\n    uint256 public constant DISPUTE_WINDOW = 24 hours;      // Time window for disputes\n\n    // State Variables\n    mapping(address => Oracle) public oracles;\n    mapping(uint256 => Game) public games;\n    mapping(uint256 => ResultProposal) public resultProposals;\n    mapping(address => mapping(uint256 => bool)) public hasClaimed;\n    \n    address[] public activeOracles;\n    uint256 public totalGames;\n    uint256 public totalBets;\n    uint256 public totalVolume;\n\n    // Events\n    event OracleRegistered(address indexed oracle, string dataSource, uint256 stake);\n    event OracleUnregistered(address indexed oracle);\n    event GameCreated(uint256 indexed gameId, string homeTeam, string awayTeam, uint256 startTime);\n    event BetPlaced(address indexed bettor, uint256 indexed gameId, uint8 prediction, uint256 amount);\n    event ResultProposed(uint256 indexed gameId, uint8 result, address indexed oracle);\n    event ResultConfirmed(uint256 indexed gameId, uint8 result, address indexed oracle);\n    event ResultDisputed(uint256 indexed gameId, address indexed disputer, uint256 stake);\n    event DisputeResolved(uint256 indexed gameId, bool disputeSuccessful);\n    event WinningsClaimed(address indexed bettor, uint256 indexed gameId, uint256 amount);\n\n    // Constructor\n    constructor() {\n        _pause(); // Start paused for safety\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": ["*"]
      }
    },
    "evmVersion": "paris"
  }
}
